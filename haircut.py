# AUTOGENERATED! DO NOT EDIT! File to edit: haircut.ipynb.

# %% auto 0
__all__ = ['ftransform', 'FTransform', 'split_meta_data_and_code_for_line', 'split_meta_data_and_code', 'RegexNoMatchError',
           'Line', 'StackItem', 'BlockStackItem', 'LineDictOrdered', 'TraceCompiler']

# %% haircut.ipynb 2
import pandas as pd
import numpy as np
from pathlib import Path

# %% haircut.ipynb 6
# Importing necessary library
import re
import os
from functools import wraps

def ftransform(func):
    @wraps(func)
    def wrapper(args):
        return FTransform(func(args))
    return wrapper

class FTransform:
    def __init__(self, file) -> None:
        self.file = file

    def apply(self, f):
        return f(self.file)

def split_meta_data_and_code_for_line(line):
    meta_data = line[:60]
    code = line[60:]
    return meta_data, code

@ftransform
def split_meta_data_and_code(file):
    return [split_meta_data_and_code_for_line(line) for line in file]

# %% haircut.ipynb 33
class RegexNoMatchError(Exception):
    pass

class Line:
    def __init__(self, line_no, line_code, line_type):
        self.line_no = line_no
        self.line_code = line_code
        self.line_type = line_type

    def tab(self):
        self.line_code = '\t' + self.line_code

class StackItem:
    def __init__(self, class_name, func_name, line, skip=False) -> None:
        self.class_name = class_name
        self.func_name = func_name
        self.skip = skip
        self.visited_lines = [line]
    
    def add_visit(self, line):
        self.visited_lines.append(line)

    @property
    def visited_line_nos(self):
        return [line.line_no for line in self.visited_lines]

class BlockStackItem(StackItem):
    '''This is a stateful stack item'''
    def __init__(self, parent_class_name, parent_func_name, block_type, definition_line):
        super().__init__(parent_class_name, parent_func_name, definition_line)
        self.block_type = block_type
        self._lines = [definition_line]

    def add_line(self, line):
        self._lines.append(line)

    def add_line_many(self, lines):
        self._lines.extend(lines)

    def tab_lines(self):
        for line in self._lines:
            line.tab()

    @property
    def lines(self):
        return self._lines

    @property
    def line_nos(self):
        return [line.line_no for line in self._lines]

    @property
    def line_codes(self):
        return [line.line_code for line in self._lines]

class LineDictOrdered:
    def __init__(self) -> None:
        self._lines = {}

    def sort(self):
        self._lines = dict(sorted(self.lines.items()))

    def add_line(self, line: Line):
        line_no = line.line_no
        line_code = line.line_code

        self._lines[line_no] = line_code

    def add_line_many(self, lines: list[Line]):
        for line in lines:
            self.add_line(line)

    def to_list(self):
        self.sort()
        return list(self._lines.values())

    @property
    def lines(self):
        return self._lines
    

class TraceCompiler:
    classes= {}
    _stack = []
    _line_log = []

    def __init__(self, trace_path, output_path = "haircutted"):
        self._df = None
        self._trace_path = trace_path
        self._output_path = output_path

    def pre_process(self):
        try:
            with open(self._trace_path, 'r') as file:
                execution_trace = file.read()
        except FileNotFoundError:
            print(repr(file_path) + " not found. Please check the file path and try again.")


        df = pd.DataFrame(FTransform(execution_trace.split('\n')).apply(split_meta_data_and_code).file, columns=['meta_data', 'code'])
        # Remove empty row
        df = df[:-1]

        df['indent'] = df['code'].apply(lambda x: len(x) - len(x.lstrip()))
        df['diff'] = df.indent.diff()
        df['line_no'] = df['meta_data'].apply(lambda x: x.split(':')[-1].split(' ')[0])
        df['file_path'] = df['meta_data'].apply(lambda x: x.split(':')[0])
        df['line_type'] = df['meta_data'].apply(lambda meta:  list(filter(lambda x: x, meta.split(" ")))[-1]) 


        df['line_no'] = df['line_no'].astype(int)
        df['execution_order'] = df.index

        # Rearrange columns
        df = df[['execution_order', 'file_path', 'line_no', 'indent', 'diff', 'line_type' ,'code']]

        # #######################################
        # # Removing ifs that evaluate to false #
        # #######################################

        # df['has_complete_if'] = df['code'].apply(lambda x: x.strip().endswith(':') and x.strip().startswith('if'))
        # next_line_will_jump = df['line_no'].diff().shift(-1) > 1
        # next_line_new_file = df['file_path'].shift(-1) != df['file_path']
        # next_line_not_has_call = ~df['code'].shift(-1).str.contains('=>', na=False)

        # df['prune if'] = df['has_complete_if'] & (next_line_new_file | next_line_will_jump) & next_line_not_has_call
        # df = df[~df['prune if']]
        # df.drop(columns=['has_complete_if', 'prune if'], inplace=True)
        self._df = df

    def _get_func_name(self, code_snippet):
        match = re.match(r"=>\s+(\w+)", code_snippet)

        if match is None:
            raise RegexNoMatchError(f"Could not find function name in {code_snippet}")

        return match.group(1)


    def _get_self_class_name(self, code_snippet):
        match = re.match(r"=>(.*)\((self|cls)=<(\S*).*\)", code_snippet)
        
        if match is None:
            raise RegexNoMatchError(f"Could not find class name in {code_snippet}")

        return match.group(3)

    def _get_inline_class_name_from_func_name(self, func_name, code_snippet):
        match =  re.match(r".* (\S*)\." + func_name + r"\(\S*\)", code_snippet)
        
        # if match is None:
        #     match = 
        
        if match is None:
            raise RegexNoMatchError(f"Could not find class name in {code_snippet}")

        return match.group(1)

    def _get_class_name(self, code_snippet):
        try:
            return self._get_self_class_name(code_snippet)
        except RegexNoMatchError:
            pass

        try:
            previous_line = self._line_log[-2].line_code
            return self._get_inline_class_name_from_func_name(self._get_func_name(code_snippet), previous_line)
        except RegexNoMatchError:
            pass

        try:
            # Just use func name as class anme
            return self._get_func_name(code_snippet)
        except RegexNoMatchError:
            raise

    def _add_line(self, class_name, func_name, line):
        self.classes[class_name].setdefault(func_name, LineDictOrdered()).add_line(line)

    def _add_line_many(self, class_name, func_name, lines):
        self.classes[class_name].setdefault(func_name, LineDictOrdered()).add_line_many(lines)

    def _compile_func_calls(self, line):

        # Skip lambda functions TODO: might want to handle this better in the future
        if "genexpr" in line.line_code or "listcomp" in line.line_code or "lambda" in line.line_code:
            self._stack.append(StackItem(None, 'lambda', line, skip=True))
            return

        # Skip decorators TODO:might want to handle this better in the future
        if "=> inner(" in line.line_code:
            self._stack.append(StackItem(None, 'lambda', line, skip=True))
            return

        func_name = self._get_func_name(line.line_code)
        class_name = self._get_class_name(line.line_code)
        line = Line(line.line_no, f"def {line.line_code[3:]}:", line.line_type)

        self._stack.append(StackItem(class_name, func_name, line))

        if class_name not in self.classes:
            self.classes[class_name] = {}
        
        self._add_line(class_name, func_name, line)

    def _compile_line_in_block(self, line: Line):
        # For lines that are in a block within the function OR in a nested block
        if self._check_is_in_block():
            line.tab()
            self._stack[-1].add_line(line)
            return
        
        class_name = self._stack[-1].class_name
        func_name = self._stack[-1].func_name

        self._add_line(class_name, func_name, line)

    def _compile_func_return(self):
        self._stack.pop()

    def _compile_block_return(self):
        block = self._stack.pop()

        if len(block.lines) <= 1:
            if self._check_is_in_block():
                self._compile_block_return()
            return

        if self._check_is_in_block():
            block.tab_lines()
            self._stack[-1].add_line_many(block.lines)
        
            # Recurse until all existing blocks are closed
            # TODO: This assumes that if there is a line jump, then all previous nested blocks are escaped
            self._compile_block_return()
        
    
        self._add_line_many(block.class_name, block.func_name, block.lines)

    def _compile_block_entry(self, line: Line):
        parent_block = self._stack[-1]

        parent_class_name, parent_func_name = parent_block.class_name, parent_block.func_name
        block_type = line.line_code.split(" ")[0]

        self._stack.append(BlockStackItem(parent_class_name, parent_func_name, block_type, line))

    def _compile_line(self, line: Line):

        if line.line_type == "return":
            # Before closing the function, make sure all unclosed blocks are closed
            if self._check_is_in_block():
                self._compile_block_return()

            self._compile_func_return()
            return

        if line.line_type == "call":
            self._compile_func_calls(line)
            return

        if line.line_type == "line":
            if self._check_block_line_visited(line) or self._check_line_added(line):
                # this is to deal with return statements that are in a block that span multiple lines
                # the multi-line return statement will be read back on forth, ignore when it reads back
                return

            self._stack[-1].add_visit(line)
            
            if self._check_is_in_block() and self._check_block_line_jump(line):
                # TODO: if -> nested if -> nested else - the code in nested else will not be added to top level if (as it is considered a line jump)
                self._compile_block_return()
                # Do not return has we have not yet processed the current line
                # Just only know that current line is no longer in block


            # Skip functions marked to skip, eg. lambda functions
            if self._stack[-1].skip:
                return

            if line.line_code.startswith(("if", "elif", "else", "for", "with", 'while', 'try', 'except', 'finally')) and line.line_code.endswith(":"):
                self._compile_block_entry(line)
                return
            
            self._compile_line_in_block(line)

    def _check_block_line_jump(self, line):
        if len(self._stack[-1].visited_line_nos) < 2:
            return False
        
        return self._stack[-1].visited_line_nos[-1] - self._stack[-1].visited_line_nos[-2] > 1

    def _check_global_line_jump(self):
        return self._line_log[-1].line_no - self._line_log[-2].line_no > 1

    def _check_block_line_visited(self, line):
        return line.line_no in self._stack[-1].visited_line_nos

    def _check_line_added(self, line):
        curr_block = self._stack[-1]

        if curr_block.class_name not in self.classes or curr_block.func_name not in self.classes[curr_block.class_name]:
            return False

        return line.line_no in self.classes[curr_block.class_name][curr_block.func_name].lines
    

    def _check_is_in_block(self):
        if len(self._stack) == 0:
            return False

        return isinstance(self._stack[-1], BlockStackItem)

    def _check_line_in_block(self, line_no):
        return line_no in self._stack[-1].line_nos

    def _log_line(self, line):
        "History of last 5 lines processed. Useful to track back to find more info abt called function"
        if len(self._line_log) > 10:
                self._line_log = self._line_log[-10:]
        self._line_log.append(line)

    def compile(self):
        for index, row in self._df.iterrows():
            line_no = row["line_no"]
            line_type = row["line_type"]
            line_code = row["code"].strip()

            line = Line(line_no, line_code, line_type)

            self._log_line(line)
            self._compile_line(line)

    def _build_class(self, class_name):
        return f"class {class_name}:"

    def _build_func(self, func_code):
        func_def = func_code[0]
        func_body = func_code[1:]

        return "\n".join(['\t' + func_def] + ['\t\t' + line for line in func_body])

    def _build_file(self, class_name, func_dict):
        code = []

        code.append(self._build_class(class_name))
        for func_code in func_dict.values():
            func_code = func_code.to_list()
            code.append(self._build_func(func_code))
            code.append('\n')

        return "\n".join(code)

    def build(self):
        for class_info, func_dict in self.classes.items():
            class_info = class_info.split(".")

            if len(class_info) < 3:
                class_path = Path("external")

            if len(class_info) < 2:
                class_file = Path(class_info[-1] + ".py")
            
            if len(class_info) >= 3:   
                class_file = Path(class_info[-2] + ".py")
                class_path = Path("/".join(class_info[:-2]))

            class_name = class_info[-1]
            
            os.makedirs(self._output_path / class_path, exist_ok=True)

            p = self._output_path / class_path / class_file
            
            if p.exists():
                with p.open(mode="a") as file:
                    file.write(self._build_file(class_name, func_dict))
            else:
                with p.open(mode="w") as file:
                    file.write(self._build_file(class_name, func_dict))

# %% haircut.ipynb 43
if __name__ == "__main__":
    tc = TraceCompiler("test.txt")
    tc.pre_process()
    tc.compile()
